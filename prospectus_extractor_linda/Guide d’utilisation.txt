üìò Guide d‚Äôutilisation ‚Äî VectorDB_Prospectus
1. Pr√©-requis

Python 3.10+ install√©

git install√© (optionnel)

Avoir un prospectus au format Word : prospectus.docx

2. Installation du projet
2.1. R√©cup√©rer le code

Depuis un terminal / PowerShell :

git clone <repo_path>
cd VectorDB_Prospectus


Ou bien copier tous les fichiers fournis dans un m√™me dossier.

2.2. Cr√©er un environnement virtuel
python -m venv .venv

# Windows
.venv\Scripts\activate

# Linux / Mac
source .venv/bin/activate

2.3. Installer les d√©pendances
pip install -r requirements.txt

3. Pr√©paration des fichiers

Placer le fichier prospectus.docx dans le m√™me dossier que main.py.

Exemple d‚Äôarborescence :

VectorDB_Prospectus/
 ‚îú‚îÄ main.py
 ‚îú‚îÄ parse_prospectus.py
 ‚îú‚îÄ prospectus_vectordb_builder.py
 ‚îú‚îÄ query_prospectus.py
 ‚îú‚îÄ section_type_refiner.py
 ‚îú‚îÄ query_utils.py
 ‚îú‚îÄ config_prospectus.py
 ‚îî‚îÄ prospectus.docx


(Optionnel) V√©rifier / adapter dans config_prospectus.py :

DEFAULT_EMBEDDING_MODEL

MAX_CHUNK_WORDS

PROSPECTUS_SECTION_PATTERNS (si besoin)

4. Configuration du LLM TokenFactory (optionnel)

Si tu veux que le mod√®le LLM corrige les section_type des chunks, il faut une cl√© API.

4.1. D√©finir la variable d‚Äôenvironnement
Windows (PowerShell) :
setx TOKENFACTORY_API_KEY "ta_cle_api"


Puis ferme et rouvre le terminal, ensuite :

.venv\Scripts\activate

Linux / Mac :
export TOKENFACTORY_API_KEY="ta_cle_api"


Si tu n‚Äôas pas de cl√©, tu peux utiliser le pipeline sans LLM (les types seront ceux de l‚Äôheuristique).

5. Construction de la VectorDB (BUILD)
5.1. Build simple (sans LLM)
python main.py build --fund-name "Nom du fonds"


Exemple :

python main.py build --fund-name "ODDO BHF US Equity Active UCITS ETF"


Cette commande :

Lit prospectus.docx

D√©tecte les sections et les tableaux

Cr√©e des chunks de ~450 mots

Assigne un section_type heuristique

Encode les chunks en embeddings

Construit l‚Äôindex FAISS + metadata

Les fichiers g√©n√©r√©s :

outputs/
 ‚îú‚îÄ parsed/
 ‚îÇ   ‚îî‚îÄ prospectus_parsed.json
 ‚îî‚îÄ index/
     ‚îú‚îÄ prospectus_faiss.index
     ‚îî‚îÄ prospectus_metadata.json

5.2. Build avec raffinement LLM

Si TOKENFACTORY_API_KEY est configur√© :

python main.py build --fund-name "Nom du fonds" --use-llm-types


Le pipeline :

lit les chunks bruts,

appelle TokenFactory pour chaque chunk,

remplace metadata["section_type"] par un type canonique UCITS corrig√©.

üí° Conseil :

Lancer d‚Äôabord un build sans LLM

V√©rifier prospectus_parsed.json

Relancer avec --use-llm-types une fois que le parsing est OK.

6. Interroger la VectorDB (QUERY)

Commande g√©n√©rale :

python main.py query --query "ta question" [options]

6.1. Recherche s√©mantique simple
python main.py query \
  --query "What is the investment objective of the fund?"

6.2. Ajuster le nombre de r√©sultats (top-k)
python main.py query \
  --query "main risks" \
  --top-k 5

6.3. Filtrer par type de section
python main.py query \
  --query "dividend distribution" \
  --section-filter "distribution_policy"


Plusieurs types :

python main.py query \
  --query "investment objective" \
  --section-filter "objective,strategy"

6.4. Expansion de query (synonymes)
python main.py query \
  --query "investment objective" \
  --expansion \
  --section-filter "objective"


Le texte de la query sera enrichi avec des synonymes d√©finis dans QUERY_EXPANSIONS.

6.5. Re-ranking avec cross-encoder
python main.py query \
  --query "What are the main risks?" \
  --section-filter "risk_profile" \
  --reranking


Le pipeline :

R√©cup√®re les r√©sultats par embeddings

Les r√©-ordonne avec un mod√®le CrossEncoder

6.6. Score minimum
python main.py query \
  --query "investment objective" \
  --min-score 0.30


Les r√©sultats de score inf√©rieur √† 0.30 sont filtr√©s.

6.7. Ajouter le contexte (avant / apr√®s)
python main.py query \
  --query "main risks" \
  --section-filter "risk_profile" \
  --context


La sortie affichera aussi :

Context BEFORE

Context AFTER

pour chaque chunk s√©lectionn√©.

7. Recherche hybride (semantic + BM25)

Pour combiner :

Similarit√© embeddings

Recherche par mots-cl√©s (BM25)

Utilise --hybrid :

python main.py query \
  --query "dividend payment policy" \
  --hybrid \
  --top-k 5


La console affiche :

semantic_score

keyword_score

score = combinaison des deux

Les poids sont d√©finis dans query_prospectus_hybrid :

semantic_weight=0.7
keyword_weight=0.3


que tu peux ajuster dans le code si besoin.

8. Comparer les m√©thodes de recherche

Utilise la commande compare :

python main.py compare \
  --query "investment objective" \
  --top-k 3


Cela lance :

Recherche s√©mantique simple

Recherche hybride

Recherche hybride + reranking

et affiche les r√©sultats pour comparer.

9. Mode ‚ÄúALL‚Äù (build + test query)

Pour tout encha√Æner :

python main.py all --use-llm-types


Cette commande :

Ex√©cute build (avec LLM si possible)

Lance une query de test :

"What is the investment objective of the fund?"

10. R√©sum√© des options principales
Option	Utilit√©
--fund-name	Nom du fonds dans les m√©tadonn√©es
--use-llm-types	Utiliser TokenFactory pour corriger section_type
--query	Texte de la question
--top-k	Nombre de r√©sultats retourn√©s
--section-filter	Filtrer par type de section (objective, fees, etc.)
--expansion	Ajouter des synonymes √† la query
--hybrid	Combiner embeddings + BM25
--reranking	Re-ranker les r√©sultats via CrossEncoder
--context	Afficher les chunks avant/apr√®s
--min-score	Score minimum des r√©sultats
11. En cas de probl√®me

Erreur : index introuvable
‚Üí lancer d‚Äôabord :

python main.py build


Changement de mod√®le d‚Äôembeddings
‚Üí supprimer outputs/index/ puis relancer build.

Prospectus mal d√©coup√©
‚Üí v√©rifier que les titres sont bien format√©s (styles Heading ou MAJUSCULES).